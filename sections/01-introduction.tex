\section{Introduction}

% What's the problem that we're trying to solve.
First introduced in 2015, Intel's Software Guard Extensions (SGX) technology
inspired diverse applications but also increasingly sophisticated attacks:
researchers successfully adapted speculative execution
attacks~\cite{VanBulck2018a}, injected software faults~\cite{Murdock2020a}, and
exploited side channels introduced by shared caches~\cite{Brasser2017a}, all
with the goal of exfiltrating information that was meant to remain in the
enclave.  The underlying flaw that most attacks take advantage of is that the
untrustworthy operating system and the enclave share a CPU, which invites side
channel attacks.  On top of that, SGX remains difficult to use and imposes
significant resource constraints~\cite{Ngoc2019a}.

% How Nitro enclaves are better.
Several cloud providers began in 2020 to offer ``confidential computing''
solutions.  Google's is based on AMD's Secure Encrypted Virtualization
(SEV)~\cite{googlecc} while Microsoft's is based on SGX~\cite{azurecc}.  Both
offerings inherit the attack classes that plague their respective architectures.
Amazon took a different path by offering a new enclave architecture based on
their custom Nitro system~\cite{nitro-enclaves}.  Nitro enclaves are
virtual machines with hardware-enforced CPU, memory, and device isolation.
%
While the architecture appears promising, Nitro enclaves remain difficult to
use: documentation is sparse, few applications exist, and enclaves can only
interact with the parent EC2 instance via a constrained, socket-like interface.
% Research questions.
In this paper, we answer the following research questions.
\begin{description}
  \item[$RQ_1$] How can we abstract away the complexity of working with Nitro
    enclaves?
  \item[$RQ_2$] What workloads (in latency and throughput) can Nitro enclaves
    sustain?
  \item[$RQ_3$] What new enclave applications emerge?
\end{description}

% How we answer RQ1.
We answer $RQ_1$ by presenting the design and implementation of \tool{}: a tool
kit for rapidly developing networked Nitro enclave applications.  \Tool{}
abstracts away the complexity and pitfalls of working with Nitro enclaves,
making it possible to run Docker images inside an enclave without modification.
Our evaluation shows that a single \tool{}-powered enclave enables low-latency
and high-throughput use cases like HD video calls but we further push the
envelope by designing an enclave synchronization mechanism to scale enclaves,
which can handle intense work loads.

% How we answer RQ2.
Having developed \tool{}, we move on to answering $RQ_2$.  We study the
latency and throughput guarantees of Nitro enclaves in general and \tool{} in
particular.  We find that Nitro enclaves have overhead in both latency
($\approx$1.2x) and throughput ($\approx$7x) compared to a system running in
Docker but this overhead still allows for low-latency and high-throughput
enclave applications.

% How we answer RQ3.
We answer $RQ_3$ by putting \tool{} to the test.  We built two novel enclave
applications that take advantage of \tool{}'s flexiblity and performance.  The
first application is a Tor bridge running inside an enclave, which allows users
to convince themselves (using remote attestation) that the bridge is running
authentic and unmodified Tor code.  We found that this enclave-enabled Tor
bridge allows for convenient Web browsing---2160p YouTube videos played smoothly
and without buffering.  The second application allows a service provider to
grant its users insight into previously-confidential infrastructure
configuration.  By deploying a ``configuration query service'' inside an
enclave, users have proof that the service provider's privacy promises are
reflected in infrastructure configuration.

\paragraph{Structure}

Section~\ref{sec:background} provides background on secure enclaves in general
and AWS Nitro enclaves in particular.  Section~\ref{sec:design} introduces the
design and implementation of \tool{}, followed by
Section~\ref{sec:applications} presenting two production-quality applications
that we built with \tool{}.  We evaluate \tool{} in
Section~\ref{sec:evaluation} and discuss its limitations in
Section~\ref{sec:limitations}.  Finally, Section~\ref{sec:related-work}
contrasts our work with past research and we conclude in
Section~\ref{sec:conclusion}.
